---
title: 类加载机制
date: 2022-03-11 14:27:01
permalink: /jvm/classloader
categories:
  - 面试
  - 八股文
  - JVM
tags:
  - 类加载机制
  - JVM
author:
    name: janker0718 
    link: https://github.com/janker0718

---

# 类加载机制

## 类加载运行全过程
当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到 JVM。
```java
public class HelloWorld {
    public static final int initValue = 88;

    public int cal() {
        int m =5;
        int n = 4;
        int p = (m+n)* 100;

        return p;
    }

    public static void main(String[] args) {
        
        new HelloWorld().cal();
    }
}
```
Java命令执行代码流程图

![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/javac-exec-flow.png)

其中loadClass的类加载过程有如下几步:
**加载** >> **验证** >> **准备** >> **解析** >> **初始化** >> **使用** >> **卸载**

- **加载**:在硬盘上查找并通过 `IO` 读入字节码文件，使用到类时才会加载，例如调用类的 `main()` 方法，`new` 对象等等，在加载阶段会在内存中生成一个**代表这个类的 `java.lang.Class`对象**，作为方法区这个类的各种数据的访问入口。

- **验证**: 校验字节码文件的正确性
- **准备**: 给类的静态变量分配内存，并赋予默认值
- **解析**: 将**符号引用**替换为直接引用，该阶段会把一些静态方法(**符号引用**，比如 `main()`方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的**静态链接**过程(类加载期间完成)，**动态链接**是在程序运行期间完成的将符号引用替换为直接引用

- **初始化**: 对类的静态变量初始化为指定的值，执行静态代码块



类被加载到方法区中后主要包含 **运行时常量池**、**类型信息**、**字段信息**、**方法信息**、**类加载器的引用**、**对应class实例的引用**等信息。
**类加载器的引用**: 这个类到类加载器实例的引用 对应 `class` 实例的引用:类加载器在加载类信息放到方法区中后，会创建一个对应的 `Class` 类型的 对象实例放到堆(`Heap`)中, 作为开发人员访问方法区中类定义的入口和切入点。

**注意**，主类在运行过程中如果使用到其它类，会逐步加载这些类。 `jar` 包或 `war` 包里的类不是一次性全部加载的，是使用到时才加载。

```java

public class DynamicLoadTest {

    static {
        System.out.println("************* load DynamicLoadTest ************");
    }

    public static void main(String[] args) {
        new A();
        System.out.println("*************load test************");
        B b = null; //B不会加载，除非这里执行 new B()
    }
}

class A {
    static {
        System.out.println("*************load A************");
    }

    public A() {
        System.out.println("*************initial A************");
    }
}

class B {
    static {
        System.out.println("*************load B************");
    }

    public B() {
        System.out.println("*************initial B************");
    }
}

```

```shell
## 运行结果
************* load DynamicLoadTest ************
*************load A************
*************initial A************
*************load test************
```

## 类加载器和双亲委派机制

上面的类加载过程主要是通过类加载器来实现的，`Java` 里有如下几种类加载器

- 引导类加载器:负责加载支撑 `JVM` 运行的位于 `JRE` 的 `lib` 目录下的核心类库，比如 `rt.jar`、`charsets.jar`等
- 扩展类加载器:负责加载支撑 `JVM` 运行的位于 `JRE` 的 `lib` 目录下的 `ext` 扩展目录中的 `JAR` 类包
- 应用程序类加载器:负责加载 `ClassPath` 路径下的类包，主要就是加载你自己写的那 些类
- 自定义加载器:负责加载用户自定义路径下的类包

**类加载器示例**

```java
public class JDKClassLoaderTest {
    public static void main(String[] args) {

        System.out.println(String.class.getClassLoader());

        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());

        System.out.println(JDKClassLoaderTest.class.getClassLoader().getClass().getName());
        System.out.println("-------------分割线-------------");

        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();
        ClassLoader extClassloader = appClassLoader.getParent();
        ClassLoader bootstrapLoader = extClassloader.getParent();
        System.out.println("the bootstrapLoader : " + bootstrapLoader);
        System.out.println("the extClassloader : " + extClassloader);
        System.out.println("the appClassLoader : " + appClassLoader);
        System.out.println();
        System.out.println("bootstrapLoader加载以下文件:");
        URL[] urls = Launcher.getBootstrapClassPath().getURLs();
        for (int i = 0; i < urls.length; i++) {
            System.out.println(urls[i]);
        }
        System.out.println();
        System.out.println("extClassloader加载以下文件:");
        System.out.println(System.getProperty("java.ext.dirs"));
        System.out.println();
        System.out.println("appClassLoader加载以下文件:");
        System.out.println(System.getProperty("java.class.path"));

    }
}
```

```shell
## 运行结果
null
sun.misc.Launcher$ExtClassLoader
sun.misc.Launcher$AppClassLoader
-------------分割线-------------
the bootstrapLoader : null
the extClassloader : sun.misc.Launcher$ExtClassLoader@31befd9f
the appClassLoader : sun.misc.Launcher$AppClassLoader@18b4aac2

bootstrapLoader加载以下文件:
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/resources.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/rt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/sunrsasign.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jsse.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jce.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/charsets.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfr.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/classes

extClassloader加载以下文件:
/Users/janker/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java

appClassLoader加载以下文件:
/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/tools.jar:.......后面省略.......
```
### 类加载器初始化过程

参见类运行加载全过程图可知其中会创建JVM启动器实例`sun.misc.Launcher`。 `sun.misc.Launcher`初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 `sun.misc.Launcher`实例。
在`Launcher`构造方法内部，其创建了两个类加载器，分别是 `sun.misc.Launcher.ExtClassLoader`(扩展类加载器)和`sun.misc.Launcher.AppClassLoader`(应用类加载器)。 `JVM`默认使用`Launcher`的`getClassLoader()`方法返回的类加载器`AppClassLoader`的实例加载我们 的应用程序。

**相关源码**
```java

//Launcher的构造方法
public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
        //构造拓展类加载器，在构造的过程中将其父加载器设置为null
        var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
        throw new InternalError("Could not create extension class loader", var10);
        }

        try {
        //构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader
        //Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自 						//己写的应用程序
        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
        throw new InternalError("Could not create application class loader", var9);
        }

        Thread.currentThread().setContextClassLoader(this.loader);
        String var2 = System.getProperty("java.security.manager");
        if (var2 != null) {
        SecurityManager var3 = null;
        if (!"".equals(var2) && !"default".equals(var2)) {
        try {
        var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();
        } catch (IllegalAccessException var5) {
        } catch (InstantiationException var6) {
        } catch (ClassNotFoundException var7) {
        } catch (ClassCastException var8) {
        }
        } else {
        var3 = new SecurityManager();
        }

        if (var3 == null) {
        throw new InternalError("Could not create SecurityManager: " + var2);
        }

        System.setSecurityManager(var3);
        }

        }

```

### 双亲委派机制

JVM类加载器是有亲子层级结构的，如下图

![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/java-classload-01.png)

这里类加载其实就有一**个双亲委派机制**，加载某个类时会先委托父加载器寻找目标类，找不到再 委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的 类加载路径中查找并载入目标类。

比如我们的HelloWorld类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载 器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天 没找到 `Math` 类，则向下退回加载 `HelloWorld` 类的请求，扩展类加载器收到回复就自己加载，在自己的 类加载路径里找了半天也没找到 `HelloWorld` 类，又向下退回 `HelloWorld` 类的加载请求给应用程序类加载器， 应用程序类加载器于是在自己的类加载路径里找 `HelloWorld` 类，结果找到了就自己加载了。

**双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载**

我们来看下应用程序类加载器 `AppClassLoader` 加载类的双亲委派机制源码，`AppClassLoader` 的 `loadClass` 方法最终会调用其父类 `ClassLoader` 的 `loadClass` 方法，该方法的大体逻辑如下:

1. 首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。
2. 如果此类没有加载过，那么，再判断一下是否有父加载器;如果有父加载器，则由父加载器加载(即调用parent.loadClass(name, false);).或者是调用bootstrap类加载器来加载。
3. 如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。

```java

  //ClassLoader的loadClass方法，里面实现了双亲委派机制 
	protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
          	// 检查当前类加载器是否已经加载了该类
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                      	//如果当前加载器父加载器不为空则委托父加载器加载该类
                        c = parent.loadClass(name, false);
                    } else {
                      	//如果当前加载器父加载器为空则委托引导类加载器加载该类
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                  	//都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
              	//不会执行
                resolveClass(c);
            }
            return c;
        }
    }
    
```
**为什么要设计双亲委派机制?**

- 沙箱安全机制:自己写的`java.lang.String`.class 类不会被加载，这样便可以防止核心 `API` 库被随意篡改

- 避免类的重复加载:当父亲已经加载了该类时，就没有必要子 `ClassLoader` 再加载一次，保证被加载类的唯一性

**一个类加载示例**

```java
package java.lang;

/**
 */
public class String {
    
    public static void main(String[] args) {

        System.out.println("**************My String Class**************");
    }
}

```
```shell

## 运行结果
错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application

Process finished with exit code 1

```
**全盘负责委托机制**

“**全盘负责**”是指当一个 `ClassLoader` 装载一个类时，除非显示的使用另外一个 `ClassLoader`，该类 所依赖及引用的类也由这个 `ClassLoader` 载入。

自定义类加载器只需要继承 `java.lang.ClassLoader` 类，该类有两个核心方法，一个是 `loadClass(String, boolean)`，实现了**双亲委派机制**，还有一个方法是`findClass`，默认实现是空 方法，所以我们自定义类加载器主要是重写`findClass`方法。

```java
public class MyClassLoaderTest {
    static class MyClassLoader extends ClassLoader {
        private String classPath;

        public MyClassLoader(String classPath) {
            this.classPath = classPath;
        }

        public byte[] loadByte(String name) throws Exception {
            name = name.replaceAll("\\.", "/");
            FileInputStream fis = new FileInputStream(classPath + "/" + name
                    + ".class");
            int len = fis.available();
            byte[] data = new byte[len];
            fis.read(data);
            fis.close();
            return data;
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            try {
                byte[] data = loadByte(name);
                //defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节 数组。
                return defineClass(name, data, 0, data.length);
            }catch (Exception e){
                e.printStackTrace();
                throw new ClassNotFoundException();

            }
        }

        public static void main(String[] args) throws Exception {
            MyClassLoader classLoader = new MyClassLoader("/Users/janker/Documents/test");
            //由于本机是mac test文件放到文档目录下
            // 整体文件路径为/Users/janker/Documents/test/top/janker/java/interview/code/jvm/TestModel.class
            Class clazz = classLoader.loadClass("top.janker.java.interview.code.jvm.TestModel");
            Object obj = clazz.newInstance();
            Method method = clazz.getDeclaredMethod("print", null);
            method.invoke(obj, null);
            System.out.println(clazz.getClassLoader().getClass().getName());
        }
    }
}
```
**注意**：运行类之前记得把项目中TestModel文件注释掉

```shell
## 运行结果
=======自定义类加载器打印方法=======
top.janker.java.interview.code.jvm.MyClassLoaderTest$MyClassLoader
```

### 打破双亲委派机制

再来一个沙箱安全机制示例，尝试打破双亲委派机制，用自定义类加载器加载我们自己实现的`java.lang.String.class`

```java
public class MyClassLoader2Test {
    static class MyClassLoader extends ClassLoader {
        private String classPath;

        public MyClassLoader(String classPath) {
            this.classPath = classPath;
        }

        public static void main(String[] args) throws Exception {
            MyClassLoader classLoader = new MyClassLoader("/Users/janker/Documents/test");
            //由于本机是mac test文件放到文档目录下
            // 整体文件路径为/Users/janker/Documents/test/java/lang/String.class
            Class clazz = classLoader.loadClass("java.lang.String");
            Object obj = clazz.newInstance();
            Method method = clazz.getDeclaredMethod("print", null);
            method.invoke(obj, null);
            System.out.println(clazz.getClassLoader().getClass().getName());
        }

        public byte[] loadByte(String name) throws Exception {
            name = name.replaceAll("\\.", "/");
            FileInputStream fis = new FileInputStream(classPath + "/" + name
                    + ".class");
            int len = fis.available();
            byte[] data = new byte[len];
            fis.read(data);
            fis.close();
            return data;
        }

        @Override
        public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
            synchronized (getClassLoadingLock(name)) {
                // First, check if the class has already been loaded
                Class<?> c = findLoadedClass(name);

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            try {
                byte[] data = loadByte(name);
                //defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节 数组。
                return defineClass(name, data, 0, data.length);
            } catch (Exception e) {
                e.printStackTrace();
                throw new ClassNotFoundException();

            }
        }
    }
}


```
```shell
## 运行结果
java.lang.SecurityException: Prohibited package name: java.lang
	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:761)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:642)
```
### Tomcat打破双亲委派机制

以 `Tomcat` 类加载为例，`Tomcat` 如果使用默认的双亲委派类加载机制行不行? 我们思考一下:`Tomcat`是个`web`容器， 那么它要解决什么问题:

1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的 不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是 独立的，保证相互隔离。
2. 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程 序，那么要有10份相同的类库加载进虚拟机。
3. web容器也有自己依赖的类库，不能与应用程序的类库混淆。基于安全考虑，应该让容器的 类库和程序的类库隔离开来。
4. web容器要支持`jsp`的修改，我们知道，`jsp` 文件最终也是要编译成`class`文件才能在虚拟机中 运行，但程序运行后修改`jsp`已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。

再看看我们的问题:`Tomcat` 如果使用默认的双亲委派类加载机制行不行?

答案是不行的。为什么? 第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认 的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。 第三个问题和第一个问题一样。 我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是 `class` 文 件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的 `jsp` 是不会重新加载的。那么怎么办呢?我们可以直接卸载掉这 `jsp` 文件的类加载器，所以你应该想 到了，每个 `jsp` 文件对应一个唯一的类加载器，当一个 `jsp` 文件修改了，就直接卸载这个 `jsp` 类加载 器。重新创建类加载器，重新加载 `jsp` 文件。

**Tomcat自定义加载器详解**

![](../img/jvm/tomcat-classloader-01.png)

tomcat的几个主要类加载器:

- commonLoader:Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问;
- catalinaLoader:Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见;
- sharedLoader:各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见;
- WebappClassLoader:各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的 `WebappClassLoader`，实现相互隔离，比如不同 `war` 包应用引入了不同的 `spring` 版本， 这样实现就能加载各自的 `spring` 版本;

从图中的委派关系中可以看出: `CommonClassLoader`能加载的类都可以被`CatalinaClassLoader`和`SharedClassLoader`使用， 从而实现了公有类库的共用，而`CatalinaClassLoader`和`SharedClassLoader`自己能加载的类则 与对方相互隔离。 `WebAppClassLoader`可以使用`SharedClassLoader`加载到的类，但各个`WebAppClassLoader` 实例之间相互隔离。而`JasperLoader`的加载范围仅仅是这个 `JSP` 文件所编译出来的那一个 `.Class` 文件，它出现的目的就是为了被丢弃:当Web容器检测到JSP文件被修改时，会替换掉目前的`JasperLoader`的实例， 并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。

tomcat 这种类加载机制违背了java推荐的双亲委派模型了吗?答案是:违背了。

很显然，`tomcat` 不是这样实现，`tomcat` 为了实现隔离性，没有遵守这个约定，**每个 `webappClassLoader`加载自己的目录下的`class`文件，不会传递给父类加载器，打破了双亲委派机制。**

**模拟实现`Tomcat`的`webappClassLoader`加载自己war包应用内不同版本类实现相互共存与隔离**
```java
public class MyClassLoader3Test {
    static class MyClassLoader extends ClassLoader {
        private String classPath;

        public MyClassLoader(String classPath) {
            this.classPath = classPath;
        }

        public static void main(String[] args) throws Exception {
            MyClassLoader classLoader = new MyClassLoader("/Users/janker/Documents/test");
             Class clazz = classLoader.loadClass("top.janker.java.interview.code.jvm.TestModel");
             Object obj = clazz.newInstance();
             Method method= clazz.getDeclaredMethod("print", null);
             method.invoke(obj, null);
             System.out.println(clazz.getClassLoader());

             System.out.println();
             MyClassLoader classLoader1 = new MyClassLoader("/Users/janker/Documents/test1");
             Class clazz1 = classLoader1.loadClass("top.janker.java.interview.code.jvm.TestModel");
             Object obj1 = clazz1.newInstance();
             Method method1= clazz1.getDeclaredMethod("print", null);
             method1.invoke(obj1, null);
             System.out.println(clazz1.getClassLoader());

        }

        public byte[] loadByte(String name) throws Exception {
            name = name.replaceAll("\\.", "/");
            FileInputStream fis = new FileInputStream(classPath + "/" + name
                    + ".class");
            int len = fis.available();
            byte[] data = new byte[len];
            fis.read(data);
            fis.close();
            return data;
        }

        @Override
        public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
            synchronized (getClassLoadingLock(name)) {
                // First, check if the class has already been loaded
                Class<?> c = findLoadedClass(name);

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();

                    //非自定义的类还是走双亲委派加载
                     if (!name.startsWith("top.janker")){
                         c = this.getParent().loadClass(name);
                         }else{
                         c = findClass(name);
                         }

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            try {
                byte[] data = loadByte(name);
                //defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节 数组。
                return defineClass(name, data, 0, data.length);
            } catch (Exception e) {
                e.printStackTrace();
                throw new ClassNotFoundException();

            }
        }
    }
}
```
```shell
## 运行结果
=======自定义类加载器打印方法 test包=======
top.janker.java.interview.code.jvm.MyClassLoader3Test$MyClassLoader@1be6f5c3

=======自定义类加载器打印方法 test1包=======
top.janker.java.interview.code.jvm.MyClassLoader3Test$MyClassLoader@77459877
```
**注意**:同一个`JVM`内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一 样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类 加载器也是同一个才能认为他们是同一个。

**TestModel代码**

```
public class TestModel {

    public void print(){
        System.out.println("=======自定义类加载器打印方法 test包=======");
    }
}
```