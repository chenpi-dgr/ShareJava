---
title: JAVA算法
date: 2022-03-19 23:16:04
permalink: /algorithm/3cff36/
categories:
  - 面试
  - 八股文
  - 数据结构与算法 
tags:
  - 数据结构与算法
---
# JAVA算法

## 二分查找

又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置 的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小， 则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。

```java

    public static int biSearch(int[] array,int a){
        int lo=0;
        int hi=array.length-1;
        int mid;
        while(lo<=hi){
            mid=(lo+hi)/2;//中间位置
            if(array[mid]==a){
                return mid+1;
            }else if(array[mid]<a){ //向右查找 
                lo=mid+1;
            }else{ //向左查找 
                hi=mid-1;
            }
        }
        return -1;
    }
```

## 冒泡排序算法
1. 比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。
2. 这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第 N-1 个位置。
3. N=N-1，如果 N 不为 0 就重复前面二步，否则排序完成。
```java
public static void bubbleSort1(int[]a,int n){
        int i,j;
        for(i=0;i<n; i++){//表示 n 次排序过程。 
            for(j=1;j<n-i;j++){
            if(a[j-1]>a[j]){
            //前面的数字大于后面的数字就交换 
            // 交换 a[j-1]和 a[j]
            int temp;
            temp=a[j-1];
            a[j-1]=a[j];
            a[j]=temp;
            }
        }
    }
}

```

## 插入排序算法

通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。 插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从 桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将 它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。

如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函 数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。

![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/20220319225753.png)

```java

public void sort(int arr[]){
        for(int i=1;i<arr.length;i++){
        //插入的数
        int insertVal=arr[i];
        //被插入的位置(准备和前一个数比较)
        int index=i-1;
        //如果插入的数比被插入的数小
        while(index >= 0 && insertVal < arr[index] ){
            //将把 arr[index] 向后移动
            arr[index+1]=arr[index];
            //让 index 向前移动
            index--;
        }
        //把插入的数放入合适位置
        arr[index+1]=insertVal;
        }
}
```

## 快速排序算法

快速排序的原理:选择一个关键值作为基准值。比基准值小的都在左边序列(一般是无序的)， 比基准值大的都在右边(一般是无序的)。一般选择序列的第一个元素。

一次循环:从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有 继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比 较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的 值才交换。直到从前往后的比较索引>从后往前比较的索引，结束第一次循环，此时，对于基准值 来说，左右两边就是有序的了。

```java

import java.util.Arrays;

public class TestQuickSort {
    private static int partition(int[] arr, int low, int high) {
        //指定左指针i和右指针j
        int i = low;
        int j= high;

        //将第一个数作为基准值。挖坑
        int x = arr[low];

        //使用循环实现分区操作
        while(i<j){//5  8
            //1.从右向左移动j，找到第一个小于基准值的值 arr[j]
            while(arr[j]>=x && i<j){
                j--;
            }
            //2.将右侧找到小于基准数的值加入到左边的（坑）位置， 左指针想中间移动一个位置i++
            if(i<j){
                arr[i] = arr[j];
                i++;
            }
            //3.从左向右移动i，找到第一个大于等于基准值的值 arr[i]
            while(arr[i]<x && i<j){
                i++;
            }
            //4.将左侧找到的打印等于基准值的值加入到右边的坑中，右指针向中间移动一个位置 j--
            if(i<j){
                arr[j] = arr[i];
                j--;
            }
        }

        //使用基准值填坑，这就是基准值的最终位置
        arr[i] = x;//arr[j] = y;
        //返回基准值的位置索引
        return i; //return j;
    }
    private static void quickSort(int[] arr, int low, int high) {//???递归何时结束
        if(low < high){
            //分区操作，将一个数组分成两个分区，返回分区界限索引
            int index = partition(arr,low,high);
            //对左分区进行快排
            quickSort(arr,low,index-1);
            //对右分区进行快排
            quickSort(arr,index+1,high);
        }

    }

    public static void quickSort(int[] arr) {
        int low = 0;
        int high = arr.length-1;
        quickSort(arr,low,high);
    }

    public static void main(String[] args) {
        //给出无序数组
        int arr[] = {72,6,57,88,60,42,83,73,48,85};

        //输出无序数组
        System.out.println(Arrays.toString(arr));
        //快速排序
        quickSort(arr);
        //partition(arr,0,arr.length-1);
        //输出有序数组
        System.out.println(Arrays.toString(arr));
    }


}


```

![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/20220319230643.png)

## 希尔排序算法
基本思想:先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列 中的记录“基本有序”时，再对全体记录进行依次直接插入排序。
1. 操作方法:
   
选择一个增量序列 t1，t2，...，tk，其中 ti>tj，tk=1;
3. 按增量序列个数 k，对序列进行 k 趟排序;
4. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进 行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长 度。


![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/20220319230745.png)

```java

/**
 * 希尔排序演示
 * @author janker
 */
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {5, 1, 7, 3, 1, 6, 9, 4};
        shellSort(arr);

        for (int i : arr) {
            System.out.print(i + "\t");
        }
    }

    private static void shellSort(int[] arr) {
        //step:步长
        for (int step = arr.length / 2; step > 0; step /= 2) {
            //对一个步长区间进行比较 [step,arr.length)
            for (int i = step; i < arr.length; i++) {
                int value = arr[i];
                int j;

                //对步长区间中具体的元素进行比较
                for (j = i - step; j >= 0 && arr[j] > value; j -= step) {
                    //j为左区间的取值，j+step为右区间与左区间的对应值。
                    arr[j + step] = arr[j]; 
                }
                //此时step为一个负数，[j + step]为左区间上的初始交换值
                arr[j + step] = value;  
            }
        }
    }
}
```

## 归并排序算法
归并(Merge)排序法是将两个(或两个以上)有序表合并成一个新的有序表，即把待排序序列 分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/20220319230902.png)

```java

public class Main {
 
	public static void main(String[] args) {
		int[] arr = {11,44,23,67,88,65,34,48,9,12};
		int[] tmp = new int[arr.length];    //新建一个临时数组存放
		mergeSort(arr,0,arr.length-1,tmp);
		for(int i=0;i<arr.length;i++){
			System.out.print(arr[i]+" ");
		}
	}
	
	public static void merge(int[] arr,int low,int mid,int high,int[] tmp){
		int i = 0;
		int j = low,k = mid+1;  //左边序列和右边序列起始索引
		while(j <= mid && k <= high){
			if(arr[j] < arr[k]){
				tmp[i++] = arr[j++];
			}else{
				tmp[i++] = arr[k++];
			}
		}
		//若左边序列还有剩余，则将其全部拷贝进tmp[]中
		while(j <= mid){    
			tmp[i++] = arr[j++];
		}
		
		while(k <= high){
			tmp[i++] = arr[k++];
		}
		
		for(int t=0;t<i;t++){
			arr[low+t] = tmp[t];
		}
	}
 
	public static void mergeSort(int[] arr,int low,int high,int[] tmp){
		if(low<high){
			int mid = (low+high)/2;
			mergeSort(arr,low,mid,tmp); //对左边序列进行归并排序
			mergeSort(arr,mid+1,high,tmp);  //对右边序列进行归并排序
			merge(arr,low,mid,high,tmp);    //合并两个有序序列
		}
	}
	
}

```
## 桶排序算法
桶排序的基本思想是: 把数组 arr 划分为 n 个大小相同子区间(桶)，每个子区间各自排序，最 后合并 。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。

1. 找出待排序数组中的最大值 max、最小值 min
2. 我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max- min)/arr.length+1
3. 遍历数组 arr，计算每个元素 arr[i] 放的桶 
4. 每个桶各自排序

```java

public static void bucketSort(int[] arr){
	
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for(int i = 0; i < arr.length; i++){
        max = Math.max(max, arr[i]);
        min = Math.min(min, arr[i]);
    }
	
    //桶数
    int bucketNum = (max - min) / arr.length + 1;
    ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);
    for(int i = 0; i < bucketNum; i++){
        bucketArr.add(new ArrayList<Integer>());
    }
	
    //将每个元素放入桶
    for(int i = 0; i < arr.length; i++){
        int num = (arr[i] - min) / (arr.length);
        bucketArr.get(num).add(arr[i]);
    }
	
    //对每个桶进行排序
    for(int i = 0; i < bucketArr.size(); i++){
        Collections.sort(bucketArr.get(i));
    }
	
    System.out.println(bucketArr.toString());
	
}

```
## 基数排序算法

将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后，从最低位 开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序 列。

```java

/**
 * 基数排序
 * 平均O(d(n+r)),最好O(d(n+r)),最坏O(d(n+r));空间复杂度O(n+r);稳定;较复杂
 * d为位数,r为分配后链表的个数
 * @author zeng
 *
 */
public class RadixSort {
 
    //pos=1表示个位，pos=2表示十位
    public static int getNumInPos(int num, int pos) {
        int tmp = 1;
        for (int i = 0; i < pos - 1; i++) {
            tmp *= 10;
        }
        return (num / tmp) % 10;
    }
 
    //求得最大位数d
    public static int getMaxWeishu(int[] a) {
        int max = a[0];
        for (int i = 0; i < a.length; i++) {
            if (a[i] > max)
                max = a[i];
        }
        int tmp = 1, d = 1;
        while (true) {
            tmp *= 10;
            if (max / tmp != 0) {
                d++;
            } else
                break;
        }
        return d;
    }
 
    public static void radixSort(int[] a, int d) {
 
        int[][] array = new int[10][a.length + 1];
        for (int i = 0; i < 10; i++) {
            array[i][0] = 0;// array[i][0]记录第i行数据的个数
        }
        for (int pos = 1; pos <= d; pos++) {
            for (int i = 0; i < a.length; i++) {// 分配过程
                int row = getNumInPos(a[i], pos);
                int col = ++array[row][0];
                array[row][col] = a[i];
            }
            for (int row = 0, i = 0; row < 10; row++) {// 收集过程
                for (int col = 1; col <= array[row][0]; col++) {
                    a[i++] = array[row][col];
                }
                array[row][0] = 0;// 复位，下一个pos时还需使用
            }
        }
    }
 
    public static void main(String[] args) {
        int[] a = { 49, 38, 65, 197, 76, 213, 27, 50 };
        radixSort(a, getMaxWeishu(a));
        for (int i : a)
            System.out.print(i + " ");
    }
}
```

## 剪枝算法


在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是 剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即 确定哪些枝条应当舍弃，哪些枝条应当保留的方法。

![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/20220319231259.png)


## 回溯算法

## 最短路径算法

## 最大子数组算法

## 最小生成树算法

现在假设有一个很实际的问题:我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要 布置 n-1 一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网?


于是我们就可以引入连通图来解决我们遇到的问题，n 个城市就是图上的 n 个顶点，然后，边表示 两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有 n 个 顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连 通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。

构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质:MST 性质(假设 N=(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果(u，v)是一条具有最小权值的边， 其中 u 属于 U，v 属于 V-U，则必定存在一颗包含边(u，v)的最小生成树)，下面就介绍两种使 用 MST 性质生成最小生成树的算法:普里姆算法和克鲁斯卡尔算法。

![](https://cdn.jsdelivr.net/gh/janker0718/image_store/img/20220319231444.png)